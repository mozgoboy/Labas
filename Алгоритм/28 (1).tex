\documentclass[12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{amsfonts}
\usepackage[unicode, pdftex]{hyperref}
\usepackage{xcolor}
\begin{document} 
	\begin{center}
	{\bf\large Алгоритм упрощения дерева.}
	\end{center}
	Введем ряд определений, которые мы будем использовать для нашего алгоритма.
	\\
	
	{\bf Опр. 1} Пусть $X = \lbrace  x_{i}  \rbrace_{i=1}^{\infty} $ - множество переменных,
	$C = \lbrace  c_{i}  \rbrace_{i=1}^{\infty} $ - множество констант. $\mathbb{F}$-множество формул, такое что:
	
	1. $c_{i} \in \mathbb{F} $; 
	
	2. $x_{i} \in \mathbb{F} $; 
	
	3. $\forall f, g \in \mathbb{F} \Rightarrow \vee(f,g), \wedge(f,g), \neg f \in \mathbb{F}$.
	
	 $\vee(f,g), \wedge(f,g)$ обозначим через $f \vee g, f \wedge g$.
	\\

	{\bf Опр. 2} {\bf Уравнением  $e$} называется пара $(f_{1},f_{2})$, где $f_{1},f_{2} \in \mathbb{F}$.\\Е- множество всех уравнений.
	\\Уравнение называется {\bf простейшим}, если оно имеет вид $(x_{i}, f)$, где $f$ - произвольная формула или $(c_{i}, f)$, где $f \; != x_{j}, \forall j \in \mathbb{N}$.
	\\
	
	{\bf Опр. 3} $P$-{\bf множество предикатов}, такое что: 
	
	1. $f==g \in P$; 
	
    2. $f \subset g \in P$;
    
    3. $f \equiv \: g \in P$.
    \\
    
    {\bf Опр. 4}  $U$- {\bf множество условий}, таких что: 
    
    1. $TRUE$, $FALSE \in U$
    
    2. $p \in U$ , где $p \in P$;
    
    3. $\forall u_{1}, u_{2} \in U \Rightarrow \vee(u_{1},u_{2}), \wedge(u_{1},u_{2}), \neg u_{1} \in U$.
    \\
    
     \hypertarget{d5}{{\bf Опр. 5}} {\bf Деревом} называется $T = \; (V,\phi,\psi, \alpha, \beta)$, где: 
     
     $V$ - множество вершин,
     
      $\phi : V \rightarrow (V\times \:V)\cup \:V \cup \emptyset$ - функция потомков;
      
      $\psi : V \rightarrow V \cup \emptyset$ - функция предков;
      
      $\alpha : V \rightarrow U$ - функция условия;
      
      $\beta : V \rightarrow \lbrace  e_{i}  \rbrace_{i=1}^{n} \cup \emptyset, n \in \mathbb{N}, e \in E $ - функция уравнений.
     \\ 
        
     {\bf Опр. 6} $Vars:F \rightarrow 2^{X}$, такая что:
     
     1. $Vars(x_{i})= \lbrace x_{i} \rbrace$;
     
     2. $Vars(c_{i})=  \emptyset$;
     
     3. $Vars(\vee(f,g))= Vars(f)\cup Vars(g)$;
     
     4. $Vars(\wedge(f,g))= Vars(f)\cup Vars(g)$;
     
     5. $Vars(\neg f)= Vars(f)$.
     \\
     
     {\bf Опр. 7} Простейшее уравнение называется {\bf разрешимым} если:
     
     1. $e =(c_{i},c_{i}), \forall i \in \mathbb{N}$;
     
     2. $e =(x_{i},f) \Leftrightarrow x_{i} \;\notin Vars(f)$.
     \\
     
      {\bf Опр. 8} Вершина дерева $v$ называется {\bf вершиной уравнений}, если
     $\phi(v)=w , w \in V$, где $V$ из \hyperlink{d5}{ \textcolor{red}{Опр.5}}.
     \\
     
     {\bf Опр. 9} Вершина дерева $v$ называется {\bf выходом}, если
     $\phi(v)= \emptyset$.
     \\
     
     {\bf Опр. 10} Вершина дерева $v$ называется {\bf вершиной условия}, если
     $\phi(v)=(w,w') ,\; w,w' \in V$.
     \\
     
     {\bf Опр. 11}  Вершина дерева $v$ называется {\bf корнем дерева}, если
     $\psi(v) = \emptyset$.
     \\
     
     \hypertarget{a1}{{\bf Алгоритм 1}}
     Алгоритм сведения уравнения к системе простейших уравнений:
     
     Шаг 1. а) Если $e=(\wedge(f,g),\wedge(u,v))$, то выполняем шаг 1 для $e_{1}=(f,u)$ и $e_{2}=(g,v)$. Результат решений объединяем;
     
     б) Если $e=(\vee(f,g),\vee(u,v))$, то выполняем шаг 1 для $e_{1}=(f,u)$ и $e_{2}=(g,v)$. Результат решений объединяем;
     
     в) Если $e=(\neg f,\neg u)$, то выполняем шаг 1 для $e_{1}=(f,u)$;
     
     г) Если $e$ -простейшее, то результат - $e$;
     
     д) Если $e=(f,x_{i})$, то результат - $(x_{i}, f)$; 
     
     е) Если $e=(f,c_{i})$, то результат - $(c_{i}, f)$; 
     
     ж) Если не выполнены пункты а) ~--- \; е), то результатом является $  \emptyset $.
     \\ 
     
    \hypertarget{a2}{{\bf Алгоритм 2}} Алгоритм подстановки переменной $ (x_{i},f) $ в другое уравнение $g$: 
    
    
    а) Если $g = x_{i}$, то ответ  $f$;
    
    б) Если $g = \neg{u}$, то ответ $\neg{l}$, где $l$ - подстановка $ (x_{i},f) $ в $u$;
    
    в)$\vee (f, g)$, то ответ $\vee(l,t)$, где $l$ - подстановка $ (x_{i},f) $ в $u$,  $t$ - подстановка $ (x_{i},f) $ в $g$;
    
    г)$\wedge (f, g)$, то ответ $\wedge(l,t)$, где $l$ - подстановка $ (x_{i},f) $ в $u$, $t$ - подстановка $ (x_{i},f) $ в $g$;
    
    д) Если $g = c_{i}$, то ответ $c_{i}$;
    
    е) Если $g = x_{j}, i \neq j$, то ответ $x_{j}$.
     \\
     
      \hypertarget{a3}{{\bf Алгоритм 3}} Алгоритм выражения переменных через константы и другие переменные:
     
     Шаг 1. Применяем \hyperlink{a1}{ \textcolor{red} {Алгоритм 1}}. Если получено $\emptyset$, то выразить ничего нельзя. Переходим к шагу 2.
     
     Шаг 2. Если есть уравнения вида $(x_{i}, x_{i})$ и $(c_{i},c_{i})$, то удаляем  их из системы и переходим к шагу 3.
    
     Шаг 3. Если есть уравнения вида $(c_{i},f)$, где $f$ - нетривиальная формула, то ничего нельзя выразить. Иначе переходим к шагу 4.
     
     Шаг 4. Если у нас есть уравнения вида $(x_{i},f)$, где $x_{i} \in Vars(f)$, то ничего нельзя выразить. Иначе переходим к шагу 5.
        
     Шаг 5. Если у нас есть 2 одинаковых уравнения $e_{1}$ и $e_{2}$, то удаляем $e_{2}$, переходим к шагу 5, иначе переходим к шагу 6.
     
     Шаг 6. Если у нас есть уравнения $e_{1} =(x_{i},f)$ и $e_{2} =(x_{i},g)$, то удаляем $e_{2}$, и переходим к  шагу 1 для  уравнения   $e_{3} =(g,f)$. Иначе если оставшиеся уравнения разрешимы, то переходим к шагу 7. Иначе ничего нельзя выразить.
     
     Шаг 7. Если у нас есть уравнения вида $(x_{i},f)$ и $(x_{j},g)$, где $x_{j} \in Vars(f)$, то по \hyperlink{a2}{ \textcolor{red}{Алгоритму 2}} подставляем в уравнение $e_{1}$ выражение для $x_{j}$ и переходим к шагу 5. Иначе выводим систему выражения переменных. 
     \\
     
     \hypertarget{a4}{{\bf Алгоритм 4}} Алгоритм проверки синтаксического равенства $f == g $ при известных выражениях $ X_{i} = \left\lbrace x_{i_{1}} ......x_{i_{n}}\right\rbrace $, $i = 1,...,n$: 
       
     Шаг 1. Решаем уравнение $(f,g)$ по \hyperlink{a1}{ \textcolor{red} {Алгоритму 1}}.  Получаем  $T = \lbrace  t_{i}  \rbrace_{i=1}^{n} $- систему простейших. Если  $ T= {\emptyset}$, то возвращаем $FALSE$. Если какое-то уравнение из $T$ имеет вид $(c_{i}, h)$, где $h$ какая-то нетривиальная формула, то возвращаем $FALSE$.
     
     Шаг 2. 
     $\forall i$ удаляем $c_{i} = c_{i}$ и $x_{i} = x_{i}$;
     Если какое-то уравнение из $T$ имеет вид $(c_{i}, c_{j})$, где $i \neq j$, то возвращаем $NOTDEF$;
    
      $ \forall \: x_{j} \in X_{i}$  по \hyperlink{a2}{ \textcolor{red}{Алгоритму 2}} подставляем $x_{j}$ во все уравнения вида $e = (x_{j}, h)$. Если в результате получим уравнения вида $(c_{k}, c_{t})$, где $k \neq t$, то возвращаем $NOTDEF$. Переходим к шагу 1 для всех таких $e$, результаты объединяем (объединение с $NOTDEF$ всегда даёт $NOTDEF$).
     
     Шаг 3. Если $ T= {\emptyset}$ - $TRUE$, иначе $NOTDEF$.
     \\
     
      \hypertarget{a5}{{\bf Алгоритм 5}} Алгоритм проверки подформульного предиката $f \subset g $ при известных $ X_{i} = \left\lbrace x_{i_{1}} ......x_{i_{n}}\right\rbrace $, $i = 1,...,n$:
      
          Шаг 1. Применяем \hyperlink{a3}{ \textcolor{red}{Алгоритм 4}}  к $f == \:g$. Пусть $q_{1}$ её результат.
      
      Если $q_{1} = TRUE$, то выводим $TRUE$, иначе переходим к шагу 2.
      
      Шаг 2.а) Если  $ g = c_{i}$, то выводим $q_{1}$;
      
      б) Если $ g = x_{i}$, то выводим $q_{1}$;
      
      в) Если $ g = \neg h$, то применяем  шаг 1 к  $f\subset h$ и получаем результат $q_{2}$. Eсли $q_{2} = TRUE$, то выводим $TRUE$, если $q_{1}$ или $q_{2}$ равны $NOTDEF$, то возвращаем $NOTDEF$, иначе возвращаем $FALSE$.
      
      г) Если $ g = h_{1} \vee h_{2}$ или  $ g = h_{1} \wedge h_{2}$, то применяем  Алгоритм 5 к  $f\subset h_{1}$   и получаем результат $q_{2}$. Если $q_{2} = TRUE$, то возвращаем $q_{2}$, иначе применяем шаг 1 к $f\subset h_{2}$ и  получаем результат  $q_{3}$. Если $q_{3} = TRUE$, то возвращаем $TRUE$. Если одна из $q_{1}, q_{2}, q_{3} = NOTDEF$, то возвращаем $NOTDEF$. Иначе, возвращаем $FALSE$.
      \\
    
\begin{comment}
    Шаг 1. Если $g = c_{i}$, $g = x_{i}$, то возвращаем результат \hyperlink{a3}{ \textcolor{red}{Алгоритма 4}}. Иначе переходим к шагу 2.
  
    Шаг 2.  Если $f = \neg f_{1}$ $g = \neg g_{1}$, то применяем шаг 1 к $f_{1}$ и  $g_{1}$. Если $f$ имеет другой вид, то применяем шаг 1 к $f$ и  $g$.
     Если $g$ имеет другой вид, то переходим к шагу 3.
  
     Шаг 3. Если $g = g_{1} \wedge g_{2}$, то если \hyperlink{a4}{\textcolor{red}{Алгоритм 4}} дает $TRUE$
  \\
\end{comment}
     
     Введём элементарные эквивалентности:
     
     1) $u\wedge  FALSE\equiv FALSE$;
     
     2) $u\wedge TRUE\equiv u$;
     
     3) $u\vee FALSE\equiv u$;
     
     4) $u\vee TRUE\equiv TRUE$;
     
     5) $u \wedge \neg u \equiv FALSE$;
     
     6) $u \vee \neg u \equiv TRUE$;
     
     7) $\neg \neg u \equiv u$;
     
     8) $u\wedge (u \vee v)\equiv u$;
     
     9) $u\vee (u \wedge v)\equiv u$;
     
     10) $u \vee u \equiv u$;
     
     11) $u \wedge u \equiv u$.
     
     Таблицы истинности для функций $\wedge$, $\vee$, $\neg$ определяются аналогично таблицам алгебры логики.
     \\
     
      \hypertarget{a6}{{\bf Алгоритм 6}} Алгоритм проверки функционального предиката $f \equiv g $ при известных $ X_{i} = \left\lbrace x_{i_{1}} ......x_{i_{n}}\right\rbrace $, $i = 1,...,n$:
      
      Шаг 1. Упрощаем $f$ и $g$ по эквивалентностям, пока возможно. Переходим к шагу 2.
      
      Шаг 2. Подставляем по \hyperlink{a2}{ \textcolor{red}{Алгоритму 2}} $ X_{i} = \left\lbrace x_{i_{1}} ......x_{i_{n}}\right\rbrace $ в $f$ и $g$. Если получили $TRUE$, то возвращаем  $TRUE$.  Если получили $FALSE$, то возвращаем  $FALSE$. Иначе $NOTDEF$.
     \\
     
    
      
      \hypertarget{a7}{{\bf Алгоритм 7}} Алгоритм проверки условий для оставшихся уравнений:
     
       
       По эквивалентностям упрощаем условие, пока это возможно. Затем по   \hyperlink{a4}{ \textcolor{red}{Алгоритму 4 }},  \hyperlink{a5}{ \textcolor{red}{Алгоритму 5 }},  \hyperlink{a6}{ \textcolor{red}{Алгоритму 6}} находим значения для всех выражений. Если все значения $TRUE$, то возвращаем $TRUE$. Если все значения $FALSE$, то возвращаем $FALSE$. Если $\exists$ значения одновременно $TRUE$ и $FALSE$, то возвращаем $NOTDEF$.
      \\
      
      \hypertarget{a8}{{\bf Алгоритм 8}} Алгоритм разрешения последующих условий относительно данной вершины условия:
      
       Пусть $v$ текущая вершина условия. Пусть $\phi(v)=(v_{1},v_{2})$. Пусть $\phi(w)=(w_{1},w_{2})$. Применяем шаг 1 и шаг 2 соотвественно к вершинам $v_{1},v_{2}$.
       
       Шаг 1. a) Если текущая вершина $w$ - вершина уравнений, то применяем шаг 1 к вершине $\phi(w)$. 
       
       б) Если текущая вершина $w$ - вершина условия, то проверяем условие $\wedge(\alpha(v),\alpha(w))$ по  \hyperlink{a7}{ \textcolor{red}{Алгоритму 7}}. Если результат - $TRUE$, то "отрезаем правую ветку"$\:$вершины $w$ и применяем шаг 1 к $w_{1}$. Если результат - $FALSE$, то "отрезаем левую ветку"$\:$вершины $w$ и применяем шаг 1 к $w_{2}$. Если результат - $NOTDEF$, то применяем шаг 1 к $w_{1}$ и $w_{2}$. 
       
       Шаг 2. a) Если текущая вершина $w$ - вершина уравнений, то применяем шаг 2 к вершине $\phi(w)$.
       
        б) Если текущая вершина $w$ - вершина условия, то проверяем условие $\vee(\alpha(v),\alpha(w))$ по \hyperlink{a7}{ \textcolor{red}{Алгоритму 7}}. Если результат - $TRUE$, то "отрезаем правую ветку"$\:$вершины $w$ и применяем шаг 2 к $w_{1}$. Если результат - $FALSE$, то "отрезаем левую ветку"$\:$вершины $w$ и применяем шаг 2 к $w_{2}$. Если результат - $NOTDEF$, то применяем шаг 2 к $w_{1}$ и $w_{2}$.
      \\
      
      \hypertarget{a9}{{\bf Алгоритм 9}} Алгоритм согласования выражения всех переменных уравнения $e$:
      
      Пусть есть $n$ выражений, добавляем в каждое выражение переменные, выраженные в уравнении $e$. Затем проверяем на противоречивость все $n$ выражений, как в  \hyperlink{a3}{ \textcolor{red}{Алгоритме 3}}. Если получили противрочение во всех $n$ системах, то удаляем уравнение, иначе оставляем только непротиврочевые выражения.
      \\
      
     {\bf Главный  алгоритм} 
     
     Пусть $v$ - текущая вершина.
     Начиная с корня дерева, выполняем следующие шаги:
     
     Шаг 1. а) Если $v$ - вершина условия, то применяем  \hyperlink{a7}{ \textcolor{red}{Алгоритм 7}} к  $\alpha(v)$, если $TRUE$, то "отрезаем правую ветку".  Если $FALSE$, то "отрезаем левую ветку". Иначе, при переходе в "левую ветку"$\:$ рассматриваем только те выражения, которые дали $TRUE$ на данном условии, а при переходе в "левую ветку"$\:$ рассматриваем только те выражения, которые дали $FALSE$ на данном условии. Далее переходим к шагу 2.
     
     б) Если $v$ - вершина уравнений, то пусть $\beta : V \rightarrow \lbrace  e_{i}  \rbrace_{i=1}^{n}, n \in \mathbb{N}, e \in E$, тогда $\forall \: i$, где $ 1 \leq i \leq n$ выражаем переменные по \hyperlink{a3}{ \textcolor{red}{Алгоритму 3 }}. Если $e_{i} $ не разрешимо, то удаляем это уравнение. Далее по \hyperlink{a8}{ \textcolor{red}{Алгоритму 8}} проверяем условие $\alpha(v)$ для оставшихся уравнений. Удаляем уравнения, для которых условие не выполнено. Далее переходим к шагу 3.
          
     Шаг 2. Применяем  \hyperlink{a8}{ \textcolor{red}{Алгоритм 8}}. Пусть $\phi(v)=(w,w')$, тогда применяем шаг 1 к вершинам $w, w'$.
     
     Шаг 3. Применяем  \hyperlink{a9}{ \textcolor{red}{Алгоритм 9 }} на согласование  всех выражений. Применяем шаг 1 к вершине $\phi(v)$.
     
     
     
     
     
\end{document}	
